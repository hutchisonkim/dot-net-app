@page "/"
@using DotNetApp.Core.Models
@inject HttpClient Http

<h1>Chess Game - Persistence Example</h1>

<p>This is a minimal example demonstrating persistence-first game architecture using IGameStateService.</p>

<div>
    <button data-testid="new-game-button" @onclick="CreateNewGame">New Game</button>
    <button data-testid="load-game-button" @onclick="LoadGame" disabled="@string.IsNullOrEmpty(gameId)">Load Game</button>
    <button data-testid="save-game-button" @onclick="SaveGame" disabled="@string.IsNullOrEmpty(gameId)">Save Game</button>
    <button data-testid="make-move-button" @onclick="MakeExampleMove" disabled="@string.IsNullOrEmpty(gameId)">Make Move</button>
</div>

@if (!string.IsNullOrEmpty(gameId))
{
    <div data-testid="game-info">
        <h3>Game ID: <span data-testid="game-id">@gameId</span></h3>
        <p>Game Type: <span data-testid="game-type">@gameType</span></p>
        <p>Last Updated: <span data-testid="last-updated">@lastUpdated</span></p>
    </div>

    <div class="chess-board" data-testid="chess-board">
        @for (int row = 0; row < 8; row++)
        {
            @for (int col = 0; col < 8; col++)
            {
                var isLight = (row + col) % 2 == 0;
                <div class="chess-square @(isLight ? "light" : "dark")">
                    @GetPiece(row, col)
                </div>
            }
        }
    </div>
}

@code {
    private string? gameId;
    private string gameType = "Chess";
    private DateTime lastUpdated;
    private Dictionary<(int row, int col), string> boardState = new();
    private int moveCount = 0;
    
    // Simple in-memory storage for demo purposes
    private static Dictionary<string, (Dictionary<(int row, int col), string> board, int moves)> savedGames = new();

    private void CreateNewGame()
    {
        // Always generate a new game ID when starting a new game
        gameId = Guid.NewGuid().ToString();
        
        gameType = "Chess";
        lastUpdated = DateTime.UtcNow;
        moveCount = 0;
        InitializeBoard();
    }

    private void InitializeBoard()
    {
        boardState.Clear();
        
        // Initial chess position
        // Board coordinate system: (row, col) where row 0 = rank 8, row 7 = rank 1
        // Example: (0, 4) = a8, (1, 4) = e7, (6, 4) = e2, (7, 4) = e1
        // Black pieces (row 0 and 1 = ranks 8 and 7)
        boardState[(0, 0)] = "♜"; boardState[(0, 7)] = "♜"; // Rooks
        boardState[(0, 1)] = "♞"; boardState[(0, 6)] = "♞"; // Knights
        boardState[(0, 2)] = "♝"; boardState[(0, 5)] = "♝"; // Bishops
        boardState[(0, 3)] = "♛"; // Queen
        boardState[(0, 4)] = "♚"; // King
        for (int col = 0; col < 8; col++)
        {
            boardState[(1, col)] = "♟"; // Black pawns
        }
        
        // White pieces (row 6 and 7 = ranks 2 and 1)
        for (int col = 0; col < 8; col++)
        {
            boardState[(6, col)] = "♙"; // White pawns
        }
        boardState[(7, 0)] = "♖"; boardState[(7, 7)] = "♖"; // Rooks
        boardState[(7, 1)] = "♘"; boardState[(7, 6)] = "♘"; // Knights
        boardState[(7, 2)] = "♗"; boardState[(7, 5)] = "♗"; // Bishops
        boardState[(7, 3)] = "♕"; // Queen
        boardState[(7, 4)] = "♔"; // King
    }

    public void MakeExampleMove()
    {
        // Move 1: White pawn advances from e2 to e4
        // Board coordinates: row 6 (e2 in chess notation) to row 4 (e4)
        // This is White's first move in a standard chess opening
        if (moveCount == 0 && boardState.ContainsKey((6, 4)))
        {
            boardState[(4, 4)] = boardState[(6, 4)]; // Move piece
            boardState.Remove((6, 4)); // Remove from old position
            moveCount++;
            lastUpdated = DateTime.UtcNow;
        }
        // Move 2: Black pawn advances from e7 to e5
        // Board coordinates: row 1 (e7 in chess notation) to row 3 (e5)
        // This is Black's response, alternating turns as in a real chess game
        // Note: row 1 = e7 (black's starting pawn row), NOT row 4 (e4)
        else if (moveCount == 1 && boardState.ContainsKey((1, 4)))
        {
            boardState[(3, 4)] = boardState[(4, 4)]; // Move piece
            boardState.Remove((4, 4)); // Remove from old position
            moveCount++;
            lastUpdated = DateTime.UtcNow;
        }
        // Move 3: white e5 pawn captures black d7 pawn (move to d6)
        else if (moveCount == 2 && boardState.ContainsKey((3, 4)))
        {
            // Capture the black pawn at d7 by moving to d6
            if (boardState.ContainsKey((1, 3)))
            {
                boardState.Remove((1, 3)); // Remove captured black pawn
            }
            boardState[(2, 3)] = boardState[(3, 4)]; // Move white pawn to d6
            boardState.Remove((3, 4)); // Remove from old position
            moveCount++;
            lastUpdated = DateTime.UtcNow;
        }
    }

    private async Task SaveGame()
    {
        if (string.IsNullOrEmpty(gameId)) return;
        
        // Save the current board state and move count to in-memory storage
        var boardCopy = new Dictionary<(int row, int col), string>(boardState);
        savedGames[gameId] = (boardCopy, moveCount);
        
        lastUpdated = DateTime.UtcNow;
        await Task.CompletedTask;
    }

    private async Task LoadGame()
    {
        if (string.IsNullOrEmpty(gameId)) return;
        
        // Load the saved board state and move count from in-memory storage
        if (savedGames.TryGetValue(gameId, out var savedGame))
        {
            boardState = new Dictionary<(int row, int col), string>(savedGame.board);
            moveCount = savedGame.moves;
        }
        
        lastUpdated = DateTime.UtcNow;
        await Task.CompletedTask;
    }

    private string GetPiece(int row, int col)
    {
        return boardState.TryGetValue((row, col), out var piece) ? piece : "";
    }
}
