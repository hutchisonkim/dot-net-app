using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DotNetApp.CodeGen;

[Generator]
public sealed class ApiClientGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver) return;

        var compilation = context.Compilation;
        var contractAttr = compilation.GetTypeByMetadataName("DotNetApp.CodeGen.ApiContractAttribute");
    var getAttr = compilation.GetTypeByMetadataName("DotNetApp.CodeGen.GetAttribute");
    var postAttr = compilation.GetTypeByMetadataName("DotNetApp.CodeGen.PostAttribute");
    var putAttr = compilation.GetTypeByMetadataName("DotNetApp.CodeGen.PutAttribute");
    var deleteAttr = compilation.GetTypeByMetadataName("DotNetApp.CodeGen.DeleteAttribute");
    var bodyAttr = compilation.GetTypeByMetadataName("DotNetApp.CodeGen.BodyAttribute");
    var retryAttr = compilation.GetTypeByMetadataName("DotNetApp.CodeGen.RetryAttribute");
        if (contractAttr is null || getAttr is null) return;

        foreach (var ifaceDecl in receiver.CandidateInterfaces)
        {
            var model = compilation.GetSemanticModel(ifaceDecl.SyntaxTree);
            if (model.GetDeclaredSymbol(ifaceDecl) is not INamedTypeSymbol ifaceSymbol) continue;
            var apiAttr = ifaceSymbol.GetAttributes().FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, contractAttr));
            if (apiAttr is null) continue;
            var basePath = apiAttr.ConstructorArguments.Length == 1 ? (apiAttr.ConstructorArguments[0].Value as string ?? string.Empty) : string.Empty;
            var ns = ifaceSymbol.ContainingNamespace.IsGlobalNamespace ? "Generated" : ifaceSymbol.ContainingNamespace.ToDisplayString();
            var sb = new StringBuilder();
            var className = ifaceSymbol.Name.TrimStart('I') + "Client"; // e.g. IPlatformApi -> PlatformApiClient
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;\nusing System.Net.Http;\nusing System.Net.Http.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing System.Linq;");
            sb.AppendLine($"namespace {ns};");
            sb.AppendLine($"public sealed partial class {className} : {ifaceSymbol.ToDisplayString()} {{");
            sb.AppendLine("  private readonly HttpClient _http;\n  public " + className + "(HttpClient http) { _http = http; }");

            foreach (var member in ifaceSymbol.GetMembers().OfType<IMethodSymbol>())
            {
                if (member.MethodKind != MethodKind.Ordinary) continue;
                var attr = member.GetAttributes().FirstOrDefault(a =>
                    SymbolEqualityComparer.Default.Equals(a.AttributeClass, getAttr) ||
                    SymbolEqualityComparer.Default.Equals(a.AttributeClass, postAttr) ||
                    SymbolEqualityComparer.Default.Equals(a.AttributeClass, putAttr) ||
                    SymbolEqualityComparer.Default.Equals(a.AttributeClass, deleteAttr));
                if (attr is null) continue; // Only process annotated methods
                var verb = attr.AttributeClass?.Name switch
                {
                    "GetAttribute" => "GET",
                    "PostAttribute" => "POST",
                    "PutAttribute" => "PUT",
                    "DeleteAttribute" => "DELETE",
                    _ => "GET"
                };
                var relPath = attr.ConstructorArguments.Length == 1 ? attr.ConstructorArguments[0].Value as string ?? string.Empty : string.Empty;
                var fullPath = Combine(basePath, relPath);
                // Replace route parameters {param} if method has matching parameter name
                bool hasRouteInterpolation = false;
                foreach (var p in member.Parameters)
                {
                    var token = "{" + p.Name + "}";
                    if (fullPath.Contains(token, StringComparison.Ordinal))
                    {
                        hasRouteInterpolation = true;
                    }
                }
                var pathExpression = hasRouteInterpolation ? BuildInterpolatedPath(fullPath, member.Parameters) : $"\"{fullPath}\"";
                var returnType = member.ReturnType; // Expect Task<T> or Task
                var ctParam = member.Parameters.FirstOrDefault(p => p.Type.ToDisplayString() == "System.Threading.CancellationToken");
                var hasReturn = TryUnwrapTask(returnType, out var awaitedType);
                // Determine display type for JSON (strip nullable from reference types for deserialization generic arg)
                string? awaitedTypeDisplay = null;
                if (hasReturn && awaitedType is not null)
                {
                    awaitedTypeDisplay = awaitedType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
                    if (awaitedType.IsReferenceType && awaitedType.NullableAnnotation == NullableAnnotation.Annotated && awaitedTypeDisplay.EndsWith("?", StringComparison.Ordinal))
                    {
                        awaitedTypeDisplay = awaitedTypeDisplay.Substring(0, awaitedTypeDisplay.Length - 1);
                    }
                }
                var methodSig = member.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
                // Reconstruct method signature manually to control formatting
                var methodName = member.Name;
                var typeParams = member.TypeParameters.Length > 0 ? "<" + string.Join(",", member.TypeParameters.Select(tp => tp.Name)) + ">" : string.Empty;
                var paramList = string.Join(", ", member.Parameters.Select(p => p.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)));
                // Query parameters = non-body, non-CT simple primitives
                var bodyParam = member.Parameters.FirstOrDefault(p => p.GetAttributes().Any(a => bodyAttr!=null && SymbolEqualityComparer.Default.Equals(a.AttributeClass, bodyAttr)));
                var queryParams = member.Parameters
                    .Where(p => !SymbolEqualityComparer.Default.Equals(p, bodyParam) && !SymbolEqualityComparer.Default.Equals(p, ctParam) && !fullPath.Contains("{" + p.Name + "}", StringComparison.OrdinalIgnoreCase))
                    .ToList();

                // Build query string assembly
                if (queryParams.Any())
                {
                    sb.AppendLine("  private static string BuildQuery(IDictionary<string, object?> values){ var first=true; var sb=new System.Text.StringBuilder(); foreach(var kv in values){ if(kv.Value is null) continue; sb.Append(first?'?':'&'); first=false; sb.Append(Uri.EscapeDataString(kv.Key)); sb.Append('='); sb.Append(Uri.EscapeDataString(kv.Value.ToString()!)); } return sb.ToString(); }");
                }

                // Retry
                var retry = member.GetAttributes().FirstOrDefault(a => retryAttr!=null && SymbolEqualityComparer.Default.Equals(a.AttributeClass, retryAttr));
                var attempts = retry?.ConstructorArguments.ElementAtOrDefault(0).Value as int? ?? 1;
                var delay = retry?.ConstructorArguments.ElementAtOrDefault(1).Value as int? ?? 0;

                sb.AppendLine($"  /// <summary>Auto-generated client method for {verb} {fullPath}</summary>");
                sb.AppendLine($"  public async {returnType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)} {methodName}{typeParams}({paramList}) {{");
                var pathVar = "path" + member.Name;
                if (queryParams.Any())
                {
                    sb.AppendLine($"    var {pathVar} = {pathExpression} + BuildQuery(new Dictionary<string, object?>{{ {string.Join(", ", queryParams.Select(q => $"{{\"{q.Name}\", (object?){q.Name}}}"))} }}); ");
                }
                else
                {
                    sb.AppendLine($"    var {pathVar} = {pathExpression};");
                }
                sb.AppendLine($"    var _attempts = {attempts};");
                sb.AppendLine("    for(int _i=0; _i < _attempts; _i++){");
                sb.AppendLine("        try {");
                // Issue request
                if (verb == "GET")
                {
                    if (hasReturn && awaitedType is not null && awaitedTypeDisplay is not null)
                        sb.AppendLine($"            return await _http.GetFromJsonAsync<{awaitedTypeDisplay}>({pathVar}{(ctParam != null ? ", " + ctParam.Name : string.Empty)})!;");
                    else
                        sb.AppendLine($"            var _resp = await _http.GetAsync({pathVar}{(ctParam != null ? ", " + ctParam.Name : string.Empty)}); _resp.EnsureSuccessStatusCode(); return; ");
                }
                else // write for POST/PUT/DELETE
                {
                    var bodyExpr = bodyParam is null ? "null" : bodyParam.Name;
                    string sendCall;
                    if (verb == "DELETE")
                    {
                        sendCall = "await _http.DeleteAsync(" + pathVar + (ctParam != null ? ", " + ctParam.Name : string.Empty) + ")";
                    }
                    else if (bodyParam != null)
                    {
                        sendCall = "await _http.PostAsJsonAsync(" + pathVar + ", " + bodyParam.Name + (ctParam != null ? ", " + ctParam.Name : string.Empty) + ")";
                        if (verb == "PUT")
                            sendCall = "await _http.PutAsJsonAsync(" + pathVar + ", " + bodyParam.Name + (ctParam != null ? ", " + ctParam.Name : string.Empty) + ")";
                    }
                    else
                    {
                        sendCall = "await _http.SendAsync(new HttpRequestMessage(new HttpMethod(\"" + verb + "\"), " + pathVar + ")" + (ctParam != null ? ", " + ctParam.Name : string.Empty) + ")";
                    }
                    if (hasReturn && awaitedType is not null)
                    {
                        if (verb == "POST" || verb == "PUT" || verb == "DELETE")
                            sb.AppendLine($"            var _response = {sendCall}; _response.EnsureSuccessStatusCode(); return await _response.Content.ReadFromJsonAsync<{awaitedTypeDisplay}>({(ctParam!=null?ctParam.Name:"CancellationToken.None")})!;");
                        else
                            sb.AppendLine("            // Unexpected path");
                    }
                    else
                    {
                        sb.AppendLine($"            var _response = {sendCall}; _response.EnsureSuccessStatusCode();");
                    }
                }
                sb.AppendLine("        } catch(Exception) { if(_i == _attempts -1) throw;" + (delay > 0 ? $" await Task.Delay({delay});" : "") + " } }");
                if (hasReturn && awaitedType is not null)
                    sb.AppendLine("    return default!; // Should not reach");
                sb.AppendLine("  }");
            }

            sb.AppendLine("}");
            context.AddSource(className + ".g.cs", sb.ToString());
        }
    }

    private static bool TryUnwrapTask(ITypeSymbol type, out ITypeSymbol? awaited)
    {
        awaited = null;
        if (type is INamedTypeSymbol named && named.Name == "Task")
        {
            if (named.TypeArguments.Length == 1)
            {
                awaited = named.TypeArguments[0];
                return true;
            }
            if (named.TypeArguments.Length == 0)
            {
                return false; // Task (no return)
            }
        }
        return false;
    }

    private static string Combine(string basePath, string rel)
    {
        if (string.IsNullOrEmpty(basePath)) return rel.TrimStart('/');
        if (string.IsNullOrEmpty(rel)) return basePath.TrimStart('/');
        return basePath.TrimEnd('/') + "/" + rel.TrimStart('/');
    }

    private static string BuildInterpolatedPath(string template, IEnumerable<IParameterSymbol> parameters)
    {
        // Convert api/items/{id}/sub/{slug} into $"api/items/{Uri.EscapeDataString(id.ToString()!)}..."
        var sb = new StringBuilder();
        sb.Append('$');
        sb.Append('"');
        int i = 0;
        while (i < template.Length)
        {
            if (template[i] == '{')
            {
                int end = template.IndexOf('}', i + 1);
                if (end > i)
                {
                    var name = template.Substring(i + 1, end - i - 1);
                    var param = parameters.FirstOrDefault(p => string.Equals(p.Name, name, StringComparison.Ordinal));
                    if (param != null)
                    {
                        sb.Append("{Uri.EscapeDataString(" + param.Name + ".ToString()!)}");
                        i = end + 1;
                        continue;
                    }
                }
            }
            sb.Append(template[i]);
            i++;
        }
        sb.Append('"');
        return sb.ToString();
    }

    private sealed class SyntaxReceiver : ISyntaxReceiver
    {
        public List<InterfaceDeclarationSyntax> CandidateInterfaces { get; } = new();
        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is InterfaceDeclarationSyntax ids && ids.AttributeLists.Count > 0)
            {
                CandidateInterfaces.Add(ids);
            }
        }
    }
}
